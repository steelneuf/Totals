# Repository Map Documentatie - BA Totalisatie Spring Boot Applicatie

## Overzicht van de Repository Map

De `repository/` map bevat alle Spring Data JPA repository interfaces voor de BA Totalisatie Spring Boot applicatie. Deze repositories fungeren als de data access layer en bieden CRUD operaties en custom queries voor de database entities.

**Locatie**: `src/main/java/com/totals/repository/`

**Aantal bestanden**: 2 bestanden

---

## Folder Structuur

```
repository/
├── BaRecordRepository.java    # Repository voor BA records
├── BaTotalRepository.java     # Repository voor berekende totalen
└── .REPOSITORY_DOCS.md       # Deze documentatie
```

## Bestanden in de Repository Map

### BaRecordRepository.java

**Doel**: Spring Data JPA repository interface voor `BaRecord` entities met custom queries voor data aggregatie.

**Package**: `com.totals.repository`

**Annotaties**:
- `@Repository`: Spring annotatie die deze interface markeert als een repository component

**Interface Extensie**:
- `extends JpaRepository<BaRecord, Long>`: Erft alle standaard CRUD operaties van Spring Data JPA

**Methoden**:

#### findByKenmerk(String kenmerk)
```java
@Transactional(readOnly = true)
List<BaRecord> findByKenmerk(String kenmerk);
```

**Parameters:**
- `kenmerk` (String): Kenmerk voor filtering van records

**Functionaliteit:**
1. Vindt alle `BaRecord` entities met het opgegeven kenmerk
2. Gebruikt Spring Data JPA query method naming convention
3. Retourneert lijst van alle gevonden records

**Return Type**: `List<BaRecord>`

**Transaction**: Read-only transaction voor performance optimalisatie

#### countByKenmerk(String kenmerk)
```java
@Transactional(readOnly = true)
long countByKenmerk(String kenmerk);
```

**Parameters:**
- `kenmerk` (String): Kenmerk voor counting van records

**Functionaliteit:**
1. Telt het aantal `BaRecord` entities met het opgegeven kenmerk
2. Gebruikt Spring Data JPA query method naming convention
3. Retourneert aantal records als long

**Return Type**: `long`

**Transaction**: Read-only transaction voor performance optimalisatie

#### calculateTotalsByKenmerk(String kenmerk)
```java
@Query(value = "SELECT " +
               "    :kenmerk as kenmerk, " +
               "    SUM(cijfer1) as totaal1, " +
               "    SUM(cijfer2) as totaal2, " +
               "    SUM(cijfer3) as totaal3, " +
               "    SUM(cijfer4) as totaal4, " +
               "    SUM(cijfer5) as totaal5, " +
               "    SUM(cijfer6) as totaal6, " +
               "    COUNT(*) as recordCount " +
               "FROM ba_records " +
               "WHERE kenmerk = :kenmerk", 
       nativeQuery = true)
@Transactional(readOnly = true)
Optional<BaTotalsResponse> calculateTotalsByKenmerk(@Param("kenmerk") String kenmerk);
```

**Parameters:**
- `kenmerk` (String): Kenmerk voor aggregatie van records

**Functionaliteit:**
1. Voert native SQL query uit voor database-level aggregatie
2. Sommeert alle cijfer kolommen per kenmerk
3. Telt het aantal records gebruikt in de berekening
4. Retourneert `BaTotalsResponse` DTO met geaggregeerde data
5. Gebruikt `Optional` voor null-safe return

**Return Type**: `Optional<BaTotalsResponse>`

**Transaction**: Read-only transaction voor performance optimalisatie

**SQL Query Details:**
- **SELECT**: Aggregeert alle cijfer kolommen met SUM()
- **WHERE**: Filtert op kenmerk parameter
- **COUNT**: Telt aantal records per kenmerk
- **Native Query**: Directe SQL voor optimale performance

**Dependencies:**
- `BaRecord`: Entity type voor repository operaties
- `BaTotalsResponse`: DTO voor query resultaten
- Spring Data JPA: Voor repository functionaliteit

**Gebruik in Applicatie**: Wordt gebruikt door `BaService` voor het ophalen en aggregeren van BA record data.

---

### BaTotalRepository.java

**Doel**: Spring Data JPA repository interface voor `BaTotalRecord` entities met custom update queries.

**Package**: `com.totals.repository`

**Annotaties**:
- `@Repository`: Spring annotatie die deze interface markeert als een repository component

**Interface Extensie**:
- `extends JpaRepository<BaTotalRecord, Long>`: Erft alle standaard CRUD operaties van Spring Data JPA

**Methoden**:

#### findByKenmerk(String kenmerk)
```java
Optional<BaTotalRecord> findByKenmerk(String kenmerk);
```

**Parameters:**
- `kenmerk` (String): Kenmerk voor lookup van totaal record

**Functionaliteit:**
1. Vindt het `BaTotalRecord` entity met het opgegeven kenmerk
2. Gebruikt Spring Data JPA query method naming convention
3. Retourneert Optional voor null-safe access

**Return Type**: `Optional<BaTotalRecord>`

#### updateIfNewer(...)
```java
@Modifying
@Query("UPDATE BaTotalRecord b SET b.totaal1 = :totaal1, b.totaal2 = :totaal2, b.totaal3 = :totaal3, " +
       "b.totaal4 = :totaal4, b.totaal5 = :totaal5, b.requestTimestamp = :newTimestamp " +
       "WHERE b.kenmerk = :kenmerk AND (b.requestTimestamp IS NULL OR b.requestTimestamp < :newTimestamp)")
int updateIfNewer(@Param("kenmerk") String kenmerk, 
                 @Param("totaal1") Double totaal1,
                 @Param("totaal2") Double totaal2,
                 @Param("totaal3") Double totaal3,
                 @Param("totaal4") Double totaal4,
                 @Param("totaal5") Double totaal5,
                 @Param("newTimestamp") Long newTimestamp);
```

**Parameters:**
- `kenmerk` (String): Kenmerk van het te updaten record
- `totaal1` tot `totaal5` (Double): Nieuwe totaal waarden
- `newTimestamp` (Long): Nieuwe request timestamp

**Functionaliteit:**
1. Voert JPQL UPDATE query uit op `BaTotalRecord` entities
2. Update alleen als nieuwe timestamp ouder is dan bestaande
3. Implementeert optimistic locking via timestamp vergelijking
4. Retourneert aantal geüpdatete rijen (0 of 1)

**Return Type**: `int` (aantal affected rows)

**JPQL Query Details:**
- **UPDATE**: Update operatie op BaTotalRecord entity
- **SET**: Update alle totaal velden en timestamp
- **WHERE**: Filter op kenmerk en timestamp conditie
- **Optimistic Locking**: Alleen update als nieuwe timestamp ouder is

**Dependencies:**
- `BaTotalRecord`: Entity type voor repository operaties
- Spring Data JPA: Voor repository functionaliteit

**Gebruik in Applicatie**: Wordt gebruikt door `BaService` voor het opslaan en updaten van berekende totalen.

---

## Samenwerking tussen Componenten

### Repository Integration
```
BaService
    ↓
BaRecordRepository (data ophalen)
    ↓
BaTotalRepository (resultaten opslaan)
```

### Data Flow
1. **Data Retrieval**: `BaRecordRepository.calculateTotalsByKenmerk()` haalt geaggregeerde data op
2. **Business Logic**: `BaService` voert berekeningen uit op geaggregeerde data
3. **Data Persistence**: `BaTotalRepository.updateIfNewer()` slaat resultaten op

### Query Strategy
- **Native SQL**: Voor complexe aggregatie queries (performance)
- **JPQL**: Voor entity updates (type safety)
- **Method Names**: Voor eenvoudige CRUD operaties (convenience)

## Database Query Details

### BaRecordRepository Queries

#### findByKenmerk - Generated Query
```sql
SELECT * FROM ba_records WHERE kenmerk = ?
```

#### countByKenmerk - Generated Query
```sql
SELECT COUNT(*) FROM ba_records WHERE kenmerk = ?
```

#### calculateTotalsByKenmerk - Native Query
```sql
SELECT 
    :kenmerk as kenmerk, 
    SUM(cijfer1) as totaal1, 
    SUM(cijfer2) as totaal2, 
    SUM(cijfer3) as totaal3, 
    SUM(cijfer4) as totaal4, 
    SUM(cijfer5) as totaal5, 
    SUM(cijfer6) as totaal6, 
    COUNT(*) as recordCount 
FROM ba_records 
WHERE kenmerk = :kenmerk
```

### BaTotalRepository Queries

#### findByKenmerk - Generated Query
```sql
SELECT * FROM ba_totals WHERE kenmerk = ?
```

#### updateIfNewer - JPQL Query
```sql
UPDATE ba_totals 
SET totaal1 = ?, totaal2 = ?, totaal3 = ?, totaal4 = ?, totaal5 = ?, request_timestamp = ? 
WHERE kenmerk = ? AND (request_timestamp IS NULL OR request_timestamp < ?)
```

## Transaction Management

### Read-Only Transactions
- **BaRecordRepository**: Alle queries zijn read-only
- **Performance**: Geen locking overhead voor read operaties
- **Consistency**: Snapshot isolation voor consistente reads

### Modifying Transactions
- **BaTotalRepository.updateIfNewer()**: @Modifying query
- **Automatic**: Spring Data JPA beheert transaction boundaries
- **Rollback**: Automatische rollback bij exceptions

## Performance Overwegingen

### Query Optimization
- **Native SQL**: Voor complexe aggregatie (database-level performance)
- **Indexing**: Kenmerk kolommen zijn geïndexeerd
- **Batch Operations**: Mogelijk via custom repository methods

### Memory Management
- **Optional Return**: Null-safe access zonder NullPointerExceptions
- **Lazy Loading**: Default JPA lazy loading voor associaties
- **Connection Pooling**: HikariCP voor database connection management

## Error Handling

### Repository Level
- **DataAccessException**: Spring Data JPA exceptions
- **Query Exceptions**: SQL syntax of parameter errors
- **Transaction Exceptions**: Rollback bij constraint violations

### Service Level
- **Retry Logic**: Spring Retry voor database fault tolerance
- **Exception Translation**: DataAccessException naar service exceptions

## Best Practices Geïmplementeerd

1. **Interface Segregation**: Gespecialiseerde repositories per entity type
2. **Query Optimization**: Native SQL voor complexe aggregatie
3. **Transaction Management**: Read-only waar mogelijk
4. **Parameter Binding**: @Param voor type-safe parameters
5. **Null Safety**: Optional return types waar mogelijk
6. **Optimistic Locking**: Timestamp-based concurrency control

## Troubleshooting

### Veelvoorkomende Problemen

1. **Query Syntax Errors**: Controleer native SQL syntax
2. **Parameter Binding**: Controleer @Param annotaties
3. **Transaction Issues**: Controleer @Transactional configuratie
4. **Entity Mapping**: Controleer JPA entity mappings

### Debug Tips

- Gebruik Hibernate SQL logging voor query debugging
- Test queries direct in database console
- Valideer parameter binding met verschillende waarden
- Controleer transaction boundaries in logs
